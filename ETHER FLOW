<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETHER FLOW</title>
    <style>
        :root {
            --glass: rgba(255, 255, 255, 0.1);
            --accent: #00f2ff;
        }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #050505; font-family: 'Inter', system-ui, sans-serif; color: white; }
        
        /* Modern Glassmorphism UI */
        #ui-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 30px; box-sizing: border-box;
            z-index: 10;
        }
        .panel {
            background: var(--glass);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            pointer-events: auto;
            max-width: 300px;
            transition: all 0.3s ease;
        }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; text-transform: uppercase; color: var(--accent); }
        .status-tag { font-size: 0.7rem; background: rgba(0,0,0,0.3); padding: 4px 10px; border-radius: 50px; display: inline-block; margin-top: 10px; }
        
        .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        button {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2);
            color: white; padding: 10px; border-radius: 10px; cursor: pointer; font-size: 0.8rem;
            transition: 0.2s;
        }
        button:hover { background: var(--accent); color: black; border-color: var(--accent); }
        button.active { background: var(--accent); color: black; }

        #video-preview {
            position: fixed; bottom: 30px; right: 30px;
            width: 180px; height: 130px; border-radius: 15px;
            background: #000; border: 2px solid var(--accent);
            transform: scaleX(-1); object-fit: cover;
        }
        
        @media (max-width: 600px) {
            .panel { max-width: 100%; width: 100%; }
            #video-preview { width: 120px; height: 90px; }
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="panel">
        <h1>NEBULA AI</h1>
        <div id="status" class="status-tag">Initializing Camera...</div>
        <p style="font-size: 0.8rem; opacity: 0.7;">Move your hand to influence the particles. Pinch to collapse, open palm to expand.</p>
        
        <div class="controls">
            <button onclick="changeShape('sphere')" id="btn-sphere" class="active">Sphere</button>
            <button onclick="changeShape('heart')" id="btn-heart">Heart</button>
            <button onclick="changeShape('saturn')" id="btn-saturn">Saturn</button>
            <button onclick="changeShape('flower')" id="btn-flower">Flower</button>
        </div>
    </div>
</div>

<video id="video-preview" autoplay playsinline></video>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
    import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

    // --- Scene Setup ---
    const PARTICLE_COUNT = 8000;
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    camera.position.z = 15;

    // --- Particle System Logic ---
    const geometry = new THREE.BufferGeometry();
    const posArray = new Float32Array(PARTICLE_COUNT * 3);
    const targetArray = new Float32Array(PARTICLE_COUNT * 3);
    const colorArray = new Float32Array(PARTICLE_COUNT * 3);

    // Initialize random positions
    for(let i=0; i < PARTICLE_COUNT * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 20;
        targetArray[i] = posArray[i];
        colorArray[i] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

    const material = new THREE.PointsMaterial({
        size: 0.06,
        vertexColors: true,
        transparent: true,
        blending: THREE.AdditiveBlending,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- Shape Templates ---
    window.changeShape = (shape) => {
        document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-' + shape).classList.add('active');
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            let x, y, z;
            const i3 = i * 3;
            const t = Math.random() * Math.PI * 2;
            const u = Math.random() * 2 - 1;

            if(shape === 'sphere') {
                const r = 5;
                x = r * Math.sqrt(1 - u*u) * Math.cos(t);
                y = r * Math.sqrt(1 - u*u) * Math.sin(t);
                z = r * u;
            } else if(shape === 'heart') {
                const step = (i / PARTICLE_COUNT) * Math.PI * 2;
                x = 0.5 * (16 * Math.pow(Math.sin(step), 3));
                y = 0.5 * (13 * Math.cos(step) - 5 * Math.cos(2*step) - 2 * Math.cos(3*step) - Math.cos(4*step));
                z = (Math.random() - 0.5) * 2;
            } else if(shape === 'saturn') {
                if(i < PARTICLE_COUNT * 0.5) { // Core
                    x = 3 * Math.sqrt(1 - u*u) * Math.cos(t);
                    y = 3 * Math.sqrt(1 - u*u) * Math.sin(t);
                    z = 3 * u;
                } else { // Rings
                    const r = 5 + Math.random() * 3;
                    x = r * Math.cos(t);
                    y = r * Math.sin(t) * 0.3; // Flattened
                    z = (Math.random() - 0.5);
                }
            } else if(shape === 'flower') {
                const r = 6 * Math.cos(5 * t); // 5 petals
                x = r * Math.cos(t);
                y = r * Math.sin(t);
                z = (Math.random() - 0.5) * 3;
            }
            
            targetArray[i3] = x;
            targetArray[i3+1] = y;
            targetArray[i3+2] = z;
        }
    };

    // Initialize with Sphere
    changeShape('sphere');

    // --- Hand Tracking ---
    let handX = 0, handY = 0, isHandActive = false, pinchStrength = 0;
    const videoElement = document.getElementById('video-preview');
    const status = document.getElementById('status');

    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
    hands.onResults((res) => {
        if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
            const lm = res.multiHandLandmarks[0];
            handX = (lm[9].x - 0.5) * -30; // Scale to scene
            handY = (lm[9].y - 0.5) * -20;
            
            // Pinch detection (Thumb tip to Index tip)
            const dx = lm[4].x - lm[8].x;
            const dy = lm[4].y - lm[8].y;
            pinchStrength = Math.sqrt(dx*dx + dy*dy);
            
            isHandActive = true;
            status.innerText = "Status: Tracking Hand";
            status.style.color = "var(--accent)";
        } else {
            isHandActive = false;
            status.innerText = "Status: Searching for Hand...";
            status.style.color = "white";
        }
    });

    const cameraHelper = new Camera(videoElement, {
        onFrame: async () => { await hands.send({ image: videoElement }); },
        width: 640, height: 480
    });
    cameraHelper.start().catch(() => status.innerText = "Error: Camera Access Denied");

    // --- Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.color.array;

        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            
            // LERP towards target template
            positions[i3] += (targetArray[i3] - positions[i3]) * 0.05;
            positions[i3+1] += (targetArray[i3+1] - positions[i3+1]) * 0.05;
            positions[i3+2] += (targetArray[i3+2] - positions[i3+2]) * 0.05;

            if(isHandActive) {
                const distHand = Math.hypot(positions[i3] - handX, positions[i3+1] - handY);
                
                // Interaction: Attract or Repel
                if(distHand < 5) {
                    const force = pinchStrength < 0.1 ? 0.2 : -0.15;
                    positions[i3] += (handX - positions[i3]) * force;
                    positions[i3+1] += (handY - positions[i3+1]) * force;
                    
                    // Dynamic color on touch
                    colors[i3] = 0; colors[i3+1] = 0.9; colors[i3+2] = 1.0;
                } else {
                    // Gradual color reset
                    colors[i3] += (0.5 - colors[i3]) * 0.01;
                    colors[i3+1] += (0.2 - colors[i3+1]) * 0.01;
                    colors[i3+2] += (0.8 - colors[i3+2]) * 0.01;
                }
            }
        }

        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        
        particles.rotation.y += 0.002;
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
